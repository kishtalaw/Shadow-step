<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Shadow Step — Fixed & Adaptive</title>
  <style>
    :root{
      --bg-top:#E8F7FF; --bg-bottom:#DCF3FF; --player:#7EC8E3; --accent:#FFD6A5;
      --chalk:#F2F3F4; --ui:#23343f; --muted:#B3CDE0; --shadow:rgba(35,52,63,0.12);
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));}
    .page{display:flex;align-items:center;justify-content:center;height:100%;padding:20px;box-sizing:border-box}
    #game-wrap{width:100%;max-width:920px;height:680px;border-radius:14px;overflow:hidden;position:relative;box-shadow:0 16px 40px var(--shadow);background:transparent}
    canvas{display:block;width:100%;height:100%;background:transparent}
    .ui-top{position:absolute;left:16px;top:14px;right:16px;display:flex;justify-content:space-between;align-items:center;pointer-events:none}
    .title{font-weight:800;color:var(--ui);font-size:18px;pointer-events:auto;user-select:none}
    .subtitle{font-weight:600;color:var(--muted);font-size:12px;margin-top:4px}
    .score-badge{background:rgba(255,255,255,0.75);padding:8px 12px;border-radius:12px;color:var(--ui);font-weight:700;pointer-events:auto}
    .tap-hint{position:absolute;left:50%;top:52%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.9);padding:10px 14px;border-radius:999px;color:var(--ui);font-weight:700;pointer-events:none;box-shadow:0 6px 20px rgba(35,52,63,0.08);animation:float 1.6s ease-in-out infinite}
    @keyframes float{0%{transform:translate(-50%,-48%)}50%{transform:translate(-50%,-52%)}100%{transform:translate(-50%,-48%)}}
    .modal{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:white;padding:18px;border-radius:12px;box-shadow:0 10px 40px rgba(35,52,63,0.14);min-width:280px;display:none}
    .modal.show{display:block}
    .modal h3{margin:0 0 6px 0;color:var(--ui)}
    .modal p{margin:0 0 14px 0;color:#50606f}
    .modal .actions{display:flex;gap:8px;justify-content:flex-end}
    .btn{background:var(--player);border:none;padding:8px 12px;border-radius:8px;color:white;font-weight:700;cursor:pointer}
    .btn.ghost{background:transparent;border:1px solid var(--muted);color:var(--ui)}
    footer{position:absolute;left:16px;bottom:12px;color:#3e5666;font-size:13px}
    @media (max-width:520px){#game-wrap{height:560px}}
  </style>
</head>
<body>
  <div class="page">
    <div id="game-wrap">
      <canvas id="game"></canvas>
      <div class="ui-top">
        <div style="pointer-events:auto">
          <div class="title">Shadow Step</div>
          <div class="subtitle">Tap to step — switch rooftops</div>
        </div>
        <div class="score-badge" id="score">Score: 0</div>
      </div>
      <div class="tap-hint" id="tapHint">Tap • Switch</div>
      <div class="modal" id="modal">
        <h3 id="modalTitle">Nice Run</h3>
        <p id="modalText">Score: 0</p>
        <div class="actions">
          <button class="btn" id="shareBtn">Download Snapshot</button>
          <button class="btn ghost" id="retryBtn">Retry</button>
        </div>
      </div>
      <footer id="tip">Tip: lanes move at same speed — rhythm beats haste.</footer>
    </div>
  </div>

<script>
(() => {
  // ---- canvas + sizing ----
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  let W = 800, H = 600, patternW = 160;

  // lane centers declared early (avoid TDZ)
  let laneY = [Math.round(H * 0.42), Math.round(H * 0.68)];

  function dims(){
    W = canvas.width / DPR;
    H = canvas.height / DPR;
    patternW = Math.max(120, Math.round(W * 0.18));
    laneY = [Math.round(H * 0.42), Math.round(H * 0.68)];
    if(window.__ss_player){
      window.__ss_player.r = Math.round(Math.min(W,H) * 0.032);
      window.__ss_player.y = laneY[window.__ss_player.lane];
      window.__ss_player.targetY = laneY[window.__ss_player.lane];
      window.__ss_player.originY = window.__ss_player.y;
      window.__ss_player.x = Math.round(W * 0.18);
    }
  }

  function resize(){
    const rect = document.getElementById('game-wrap').getBoundingClientRect();
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    dims();
  }
  window.addEventListener('resize', resize);
  resize();

  // ---- UI elements ----
  const scoreEl = document.getElementById('score');
  const tapHint = document.getElementById('tapHint');
  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalText = document.getElementById('modalText');
  const shareBtn = document.getElementById('shareBtn');
  const retryBtn = document.getElementById('retryBtn');
  const tipEl = document.getElementById('tip');

  // ---- audio / haptics ----
  let soundOn = true;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function playClick(){ if(!soundOn||!AudioCtx) return; if(!audioCtx) audioCtx=new AudioCtx(); const osc=audioCtx.createOscillator(); const g=audioCtx.createGain(); osc.type='sine'; osc.frequency.value=440; g.gain.value=0.04; osc.connect(g); g.connect(audioCtx.destination); osc.start(); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.08); osc.stop(audioCtx.currentTime+0.09); }
  function vibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

  // ---- player ----
  const player = {
    x: Math.round(W * 0.18),
    lane: 0,
    y: laneY[0],
    targetY: laneY[0],
    r: Math.round(Math.min(W,H) * 0.032),
    slideT: 0,
    slideDur: 160,
    originY: laneY[0]
  };
  window.__ss_player = player;

  // ---- world / state ----
  let obstacles = [], lanterns = [], particles = [];
  let frame = 0;
  let playing = false, gameOver = false, score = 0;
  let speed = Math.max(3, Math.round(W * 0.006));
  let lastSpawnTime = performance.now();
  const minTimeGap = 360;

  // ---- adaptive difficulty ----
  let difficulty = 0.0;               // 0..1
  const DIFF_MAX = 1.0;
  const DIFF_GROW_PER_PASS = 0.012;
  const DIFF_GROW_PER_SCORE = 0.000015;
  const BASE_SPEED = Math.max(3, Math.round(W * 0.006));
  const MAX_SPEED = BASE_SPEED * 1.8;
  const BASE_OPPOSITE_GAP_FRAC = 0.34;
  const MIN_OPPOSITE_GAP_FRAC = 0.20;

  function speedForDifficulty(){
    return BASE_SPEED + (MAX_SPEED - BASE_SPEED) * difficulty;
  }
  function oppositeGapForDifficulty(){
    const frac = BASE_OPPOSITE_GAP_FRAC - (BASE_OPPOSITE_GAP_FRAC - MIN_OPPOSITE_GAP_FRAC) * difficulty;
    return Math.round(W * Math.max(MIN_OPPOSITE_GAP_FRAC, frac));
  }

  // ---- alternation tuning ----
  const alternationChanceWhenFar = 0.78; // increase chances to flip lane
  const oppositeGapFactorBase = 1.08;    // multiplier for base gap (smaller => faster alternation)
  const oppositeGapMinWidthFrac = 0.28;

  function rand(){ return Math.random(); }

  // ---- collisions ----
  function circleRectCollision(cx,cy,r,rx,ry,rw,rh){
    const cx0 = Math.max(rx, Math.min(cx, rx+rw));
    const cy0 = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx-cx0, dy = cy-cy0;
    return (dx*dx + dy*dy) < (r*r + 0.0001);
  }

  // ---- drawing helpers ----
  function setStrokeChalk(){ ctx.lineJoin='round'; ctx.lineCap='round'; ctx.lineWidth=Math.max(2,Math.min(W,H)*0.006); ctx.strokeStyle='rgba(242,243,244,0.96)'; }

  function drawRoof(x,y){
    ctx.beginPath(); setStrokeChalk(); ctx.strokeStyle='rgba(242,243,244,0.9)';
    ctx.moveTo(x,y); ctx.lineTo(x+20,y-6); ctx.lineTo(x+40,y+2); ctx.lineTo(x+80,y-4); ctx.lineTo(x+120,y+6); ctx.lineTo(x+patternW,y); ctx.stroke();
    ctx.beginPath(); ctx.strokeStyle='rgba(35,52,63,0.05)'; ctx.lineWidth=1; ctx.moveTo(x+6,y+6); ctx.lineTo(x+140,y+8); ctx.stroke();
  }

  function drawPlayer(){
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.06)'; ctx.ellipse(player.x+6,player.y+player.r*0.9,player.r*1.1,player.r*0.45,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.98)'; ctx.ellipse(player.x,player.y,player.r,player.r*0.95,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.95)'; ctx.lineWidth=Math.max(2,player.r*0.12); ctx.ellipse(player.x,player.y,player.r*0.86,player.r*0.82,0,0,Math.PI*2); ctx.stroke();
  }

  function drawChimney(ob){
    const cx = ob.x, lane = ob.lane, w = ob.w, h = ob.h;
    const by = laneY[lane];
    const x = cx - w/2, y = by - h;
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.95)'; ctx.fillRect(x,y,w,h);
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.9)'; ctx.lineWidth=Math.max(2,W*0.006); ctx.strokeRect(x,y,w,h);
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.98)'; ctx.fillRect(x-w*0.2,y-w*0.28,w*1.4,w*0.28);
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.9)'; ctx.strokeRect(x-w*0.2,y-w*0.28,w*1.4,w*0.28);
  }

  function drawLantern(x,y){
    ctx.beginPath(); ctx.fillStyle='rgba(255,214,165,0.08)'; ctx.ellipse(x,y,22,22,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle='rgba(255,214,165,0.98)'; ctx.ellipse(x,y,10,12,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.95)'; ctx.lineWidth=1.5; ctx.ellipse(x,y,10,12,0,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.5)'; ctx.lineWidth=1; ctx.moveTo(x,y-12); ctx.lineTo(x,y-20); ctx.stroke();
  }

  function spawnParticles(x,y){
    for(let i=0;i<18;i++){
      particles.push({
        x: x + (rand()-0.5)*12,
        y: y + (rand()-0.5)*12,
        vx: (rand()-0.5)*2,
        vy: -1 - rand()*2,
        life: 800, age:0,
        c: (i%2===0? 'rgba(255,214,165,0.95)':'rgba(126,200,227,0.95)')
      });
    }
  }

  // ---- obstacle spawn logic ----
  function pushLantern(x){ const lane = rand()<0.6?1:0; const offsetY = (rand()*0.3-0.15)*(lane===0?H*0.06:H*0.045); lanterns.push({x:x,lane:lane,offsetY:offsetY,taken:false}); }

  function pushObstacle(atX, opts = {}){
    // safety / spacing derived from player size + difficulty
    const minSpawnPx = Math.round(player.r * 6);
    const baseHorizontalGap = opts.minHorizontalGap || Math.max(minSpawnPx, Math.round(W * 0.18));
    const dynamicOppositeGap = opts.minOppositeLaneGap || oppositeGapForDifficulty();
    const attempts = 5;

    // ensure not too close to last obstacle (base)
    if(obstacles.length){
      const last = obstacles[obstacles.length-1];
      const baseMin = Math.min(baseHorizontalGap, dynamicOppositeGap);
      if(atX < last.x + baseMin) atX = last.x + baseMin;
    }

    for(let attempt = 0; attempt < attempts; attempt++){
      // choose lane and encourage alternation if spacing allows
      let lane = rand() < 0.5 ? 0 : 1;
      const lastObs = obstacles[obstacles.length-1];
      if(lastObs){
        const dist = Math.abs(lastObs.x - atX);
        // if far enough, high chance to flip lane
        if(dist >= Math.round(dynamicOppositeGap * 0.6)){
          if(rand() < alternationChanceWhenFar) lane = 1 - lastObs.lane;
        } else {
          // if too close and would be opposite lane, prefer same lane to avoid impossible pair
          if(lastObs.lane !== lane && dist < dynamicOppositeGap){
            if(rand() < 0.9) lane = lastObs.lane;
          }
        }
      }

      // height computation with safety caps
      const minH = Math.round(Math.max(8, player.r * 0.9));
      const rawH = Math.round(H * (0.10 + rand() * 0.28));
      let h = rawH;

      // stronger vertical safety clearance that scales slightly with difficulty
      const minJumpClearance = Math.round(player.r * (1.4 + 0.6 * difficulty)) + 8;

      if(lane === 1){
        // lower lane: cap height so it doesn't intrude into upper lane's area
        const laneGap = Math.max(0, laneY[1] - laneY[0]);
        const maxAllowedLowerH = Math.max(minH, laneGap - minJumpClearance - 6);
        h = Math.min(h, maxAllowedLowerH);
      } else {
        // upper lane: keep reasonable maximum
        const maxUpperH = Math.max(minH, Math.round(H * 0.36));
        h = Math.min(h, maxUpperH);
      }
      h = Math.max(minH, h);

      // horizontal spacing enforcement depending on lane relationship
      if(obstacles.length){
        const last = obstacles[obstacles.length-1];
        const dist = Math.abs(last.x - atX);
        if(last.lane !== lane){
          if(dist < dynamicOppositeGap){
            atX = last.x + dynamicOppositeGap;
          }
        } else {
          if(dist < baseHorizontalGap){
            atX = last.x + baseHorizontalGap;
          }
        }
      }

      // push obstacle
      obstacles.push({ x: atX, lane: lane, h: h, w: Math.round(W * 0.06), passed: false });
      return;
    }

    // fallback in case all attempts fail
    const fallbackH = Math.max(8, Math.round(player.r*0.9));
    let finalX = atX;
    if(obstacles.length){
      const last = obstacles[obstacles.length-1];
      const minGap = Math.max(Math.round(player.r*6), Math.round(W * 0.18));
      if(finalX < last.x + minGap) finalX = last.x + minGap;
    }
    obstacles.push({x:finalX, lane:0, h:fallbackH, w:Math.round(W*0.06), passed:false});
  }

  // ---- input / control ----
  function switchLane(){
    if(gameOver) return;
    if(!playing){ playing = true; tapHint.style.display = 'none'; }
    const nl = player.lane === 0 ? 1 : 0;
    player.originY = player.y; player.targetY = laneY[nl]; player.lane = nl; player.slideT = 1;
    playClick(); vibrate(15);
  }

  // ---- game over / reset ----
  function doGameOver(){
    modalTitle.textContent = 'You stumbled';
    modalText.textContent = 'Score: ' + Math.floor(score) + ' — Tap to retry';
    modal.classList.add('show');
    const prev = parseInt(localStorage.getItem('ss_highscore') || '0', 10);
    if(Math.floor(score) > prev){ localStorage.setItem('ss_highscore', String(Math.floor(score))); modalTitle.textContent = 'New High Score!'; }
  }

  function resetWorld(){
    obstacles = []; lanterns = []; particles = [];
    score = 0; frame = 0;
    difficulty = 0;
    playing = false; gameOver = false;
    player.lane = 0; player.y = laneY[0]; player.targetY = laneY[0]; player.slideT = 0; player.originY = player.y;
    player.x = Math.round(W * 0.18);
    // compute initial constants
    const minSpawnPx = Math.round(player.r * 6);
    const minHorizontalGap = Math.max(minSpawnPx, Math.round(W * 0.18));
    const minOppositeLaneGap = Math.max(Math.round(minHorizontalGap * oppositeGapFactorBase), Math.round(W * oppositeGapMinWidthFrac));
    let x = W * 0.9;
    for(let i=0;i<5;i++){
      pushObstacle(x, { minHorizontalGap, minOppositeLaneGap });
      if(rand() < 0.5) pushLantern(x - (minSpawnPx * 0.7));
      x += minSpawnPx + rand()*(minSpawnPx);
    }
    scoreEl.textContent = 'Score: 0';
    tapHint.style.display = 'block';
    modal.classList.remove('show');
    lastSpawnTime = performance.now();
  }

  // ---- main loop ----
  let lastTime = performance.now();
  function loop(now){
    const dt = Math.min(40, now - lastTime);
    lastTime = now;
    frame += dt;

    if(!gameOver && playing){
      // update speed from difficulty
      speed = speedForDifficulty();
      const move = speed * (dt / 16);
      obstacles.forEach(ob => ob.x -= move);
      lanterns.forEach(l => l.x -= move);

      // spawn logic
      const minSpawnPx = Math.round(player.r * 6);
      const minHorizontalGap = Math.max(minSpawnPx, Math.round(W * 0.18));
      const minOppositeLaneGap = oppositeGapForDifficulty();

      if((obstacles.length === 0 || (obstacles[obstacles.length-1].x < W - minHorizontalGap)) && (now - lastSpawnTime > minTimeGap)){
        pushObstacle(W + (minSpawnPx * 0.6), { minHorizontalGap, minOppositeLaneGap });
        lastSpawnTime = now;
      }

      // cleanup out-of-screen objects
      if(obstacles[0]?.x < -200) obstacles.shift();
      if(lanterns[0]?.x < -200) lanterns.shift();

      // collisions & scoring
      obstacles.forEach(ob => {
        const rx = ob.x - ob.w/2;
        const ry = (ob.lane === 0 ? laneY[0] - ob.h : laneY[1] - ob.h);
        if(circleRectCollision(player.x, player.y, player.r, rx, ry, ob.w, ob.h)){
          gameOver = true; playing = false; vibrate(80); playClick(); doGameOver();
        }
        if(!ob.passed && ob.x + ob.w/2 < player.x){
          ob.passed = true;
          score += 12;
          // increase difficulty gradually when player passes obstacles
          difficulty = Math.min(DIFF_MAX, difficulty + DIFF_GROW_PER_PASS + DIFF_GROW_PER_SCORE * score);
          scoreEl.textContent = 'Score: ' + Math.floor(score);
        }
      });

      lanterns.forEach(L => {
        if(!L.taken){
          const ly = laneY[L.lane] + L.offsetY;
          if(Math.hypot(player.x - L.x, player.y - ly) < player.r + Math.max(8, player.r*0.6)){
            L.taken = true; score += 30; spawnParticles(L.x, ly); vibrate(20); playClick(); scoreEl.textContent = 'Score: ' + Math.floor(score);
          }
        }
      });

      // small gradual score drift for heartbeat (optional)
      score += 0.01 * (dt/16);
    }

    // player slide easing
    if(player.slideT > 0){
      player.slideT += dt;
      const pVal = Math.min(1, player.slideT / player.slideDur);
      const easing = 1 - Math.pow(1 - pVal, 3);
      player.y = player.originY + (player.targetY - player.originY) * easing;
      if(player.slideT >= player.slideDur){ player.slideT = 0; player.y = player.targetY; }
    }

    draw();
    requestAnimationFrame(loop);
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    const skyH = Math.round(H*0.18);
    ctx.save(); ctx.globalAlpha = 0.28; ctx.fillStyle = 'rgba(35,52,63,0.06)'; ctx.fillRect(0, H-skyH-20, W, skyH+20); ctx.restore();

    for(let i=0;i<2;i++){
      const y = laneY[i];
      ctx.save(); ctx.translate(-((frame * 0.02) % patternW), 0);
      for(let px = -patternW; px < W + patternW; px += patternW) drawRoof(px, y);
      ctx.restore();
    }

    lanterns.forEach(L => { if(!L.taken) drawLantern(L.x, laneY[L.lane] + L.offsetY); });
    obstacles.forEach(ob => drawChimney(ob));

    particles.forEach(p => {
      p.age += 16; p.x += p.vx; p.y += p.vy; p.vy += 0.06;
      ctx.beginPath(); ctx.fillStyle = p.c; ctx.globalAlpha = 1 - (p.age / p.life);
      ctx.ellipse(p.x, p.y, 3, 3, 0, 0, Math.PI*2); ctx.fill();
    });
    particles = particles.filter(p => p.age < p.life);
    ctx.globalAlpha = 1;

    drawPlayer();
    scoreEl.textContent = 'Score: ' + Math.floor(score);
  }

  // ---- events ----
  shareBtn.addEventListener('click', () => {
    try{ const link = document.createElement('a'); link.download = `shadow-step-${Date.now()}.png`; link.href = canvas.toDataURL('image/png'); link.click(); } catch(e){ window.open(canvas.toDataURL()); }
  });
  retryBtn.addEventListener('click', () => { modal.classList.remove('show'); resetWorld(); });

  canvas.addEventListener('pointerdown', () => {
    if(gameOver) resetWorld();
    else switchLane();
  });
  window.addEventListener('keydown', e => {
    if(e.code === 'Space'){ e.preventDefault(); if(gameOver) resetWorld(); else switchLane(); }
  });

  // ---- start ----
  dims();
  resetWorld();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
