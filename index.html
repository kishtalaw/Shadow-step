<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Shadow Step — Fixed Version</title>
  <style>
    :root {
      --bg-top: #E8F7FF;
      --bg-bottom: #DCF3FF;
      --player: #7EC8E3;
      --accent: #FFD6A5;
      --chalk: #F2F3F4;
      --ui: #23343f;
      --muted: #B3CDE0;
      --shadow: rgba(35,52,63,0.12);
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));}
    .page{display:flex;align-items:center;justify-content:center;height:100%;padding:20px;box-sizing:border-box}
    #game-wrap{width:100%;max-width:920px;height:680px;border-radius:14px;overflow:hidden;position:relative;box-shadow:0 16px 40px var(--shadow);background:transparent}
    canvas{display:block;width:100%;height:100%;background:transparent}
    .ui-top{position:absolute;left:16px;top:14px;right:16px;display:flex;justify-content:space-between;align-items:center;pointer-events:none}
    .title{font-weight:800;color:var(--ui);font-size:18px;pointer-events:auto;user-select:none}
    .subtitle{font-weight:600;color:var(--muted);font-size:12px;margin-top:4px}
    .score-badge{background:rgba(255,255,255,0.75);padding:8px 12px;border-radius:12px;color:var(--ui);font-weight:700;pointer-events:auto}
    .tap-hint{position:absolute;left:50%;top:52%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.9);padding:10px 14px;border-radius:999px;color:var(--ui);font-weight:700;pointer-events:none;box-shadow:0 6px 20px rgba(35,52,63,0.08);animation:float 1.6s ease-in-out infinite}
    @keyframes float{0%{transform:translate(-50%,-48%)}50%{transform:translate(-50%,-52%)}100%{transform:translate(-50%,-48%)}}
    .modal{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:white;padding:18px;border-radius:12px;box-shadow:0 10px 40px rgba(35,52,63,0.14);min-width:280px;display:none}
    .modal.show{display:block}
    .modal h3{margin:0 0 6px 0;color:var(--ui)}
    .modal p{margin:0 0 14px 0;color:#50606f}
    .modal .actions{display:flex;gap:8px;justify-content:flex-end}
    .btn{background:var(--player);border:none;padding:8px 12px;border-radius:8px;color:white;font-weight:700;cursor:pointer}
    .btn.ghost{background:transparent;border:1px solid var(--muted);color:var(--ui)}
    footer{position:absolute;left:16px;bottom:12px;color:#3e5666;font-size:13px}
    @media (max-width:520px){#game-wrap{height:560px}}
  </style>
</head>
<body>
  <div class="page">
    <div id="game-wrap">
      <canvas id="game"></canvas>
      <div class="ui-top">
        <div style="pointer-events:auto">
          <div class="title">Shadow Step</div>
          <div class="subtitle">Tap to step — switch rooftops</div>
        </div>
        <div class="score-badge" id="score">Score: 0</div>
      </div>
      <div class="tap-hint" id="tapHint">Tap • Switch</div>
      <div class="modal" id="modal">
        <h3 id="modalTitle">Nice Run</h3>
        <p id="modalText">Score: 0</p>
        <div class="actions">
          <button class="btn" id="shareBtn">Download Snapshot</button>
          <button class="btn ghost" id="retryBtn">Retry</button>
        </div>
      </div>
      <footer>Tip: the lanes move at different speeds — use rhythm to survive.</footer>
    </div>
  </div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  let W = 800, H = 600, patternW;

  // laneY will be recalculated on resize
  let laneY = [Math.round(H * 0.42), Math.round(H * 0.68)];
  const laneSpeeds = [1.0, 0.6];

  function dims(){
    W = canvas.width / DPR;
    H = canvas.height / DPR;
    patternW = Math.max(120, Math.round(W * 0.18));
    // recompute lane Y positions so resize keeps behavior consistent
    laneY = [Math.round(H * 0.42), Math.round(H * 0.68)];
    if(window.__ss_player) {
      window.__ss_player.r = Math.round(Math.min(W,H) * 0.032);
      // keep player vertical positions consistent if possible
      window.__ss_player.y = laneY[window.__ss_player.lane];
      window.__ss_player.targetY = laneY[window.__ss_player.lane];
      window.__ss_player.originY = window.__ss_player.y;
    }
  }

  function resize(){
    const rect = document.getElementById('game-wrap').getBoundingClientRect();
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    dims();
  }
  window.addEventListener('resize', resize);
  resize();

  const scoreEl = document.getElementById('score');
  const tapHint = document.getElementById('tapHint');
  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalText = document.getElementById('modalText');
  const shareBtn = document.getElementById('shareBtn');
  const retryBtn = document.getElementById('retryBtn');
  
  let soundOn = true;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function playClick(){ if(!soundOn||!AudioCtx) return; if(!audioCtx) audioCtx=new AudioCtx(); const o=audioCtx.createOscillator();const g=audioCtx.createGain();o.type='sine';o.frequency.value=440;g.gain.value=0.04;o.connect(g);g.connect(audioCtx.destination);o.start();g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.08);o.stop(audioCtx.currentTime+0.09); }
  function vibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

  // player initial values (r and lane Y will be overwritten on dims/resize)
  const player = {
    x: Math.round(W * 0.18),
    lane: 0,
    y: laneY[0],
    targetY: laneY[0],
    r: Math.round(Math.min(W,H) * 0.032),
    slideT: 0,
    slideDur: 160,
    originY: laneY[0]
  };
  window.__ss_player = player;

  let obstacles = [], lanterns = [], particles = [], frame = 0;
  let playing = false, gameOver = false, score = 0;
  let speed = Math.max(3, Math.round(W * 0.006));
  // minSpawnPx is a base spacing unit (recomputed where needed)
  let lastSpawnTime = performance.now();
  const minTimeGap = 400;
  const minJumpClearanceBase = 8;

  function rand(){ return Math.random(); }

  function resetWorld(){
    obstacles = []; lanterns = []; particles = [];
    score = 0; frame = 0;
    speed = Math.max(3, Math.round((W||800) * 0.006));
    playing = false; gameOver = false;
    player.lane = 0; player.y = laneY[0]; player.targetY = laneY[0]; player.slideT = 0; player.originY = player.y;
    player.x = Math.round(W * 0.18);

    // compute spacing constants based on current sizes
    const minSpawnPx = Math.round(player.r * 6);
    const minHorizontalGap = Math.max(minSpawnPx, Math.round(W * 0.22));

    let x = W * 0.9;
    for(let i=0;i<5;i++){
      // ensure initial obstacles keep spacing
      pushObstacle(x, {minHorizontalGap});
      if(rand()<0.5) pushLantern(x - (minSpawnPx*0.7));
      x += minSpawnPx + rand()*(minSpawnPx);
    }
    scoreEl.textContent = 'Score: 0';
    tapHint.style.display = 'block';
    modal.classList.remove('show');
    lastSpawnTime = performance.now();
  }

  /**
   * pushObstacle(atX, opts)
   * - atX: desired spawn x
   * - opts:
   *    minHorizontalGap: force a minimum spacing from previous obstacle x (in px)
   */
  function pushObstacle(atX, opts = {}){
    const minSpawnPx = Math.round(player.r * 6);
    const minHorizontalGap = opts.minHorizontalGap || Math.max(minSpawnPx, Math.round(W * 0.22));
    const attempts = 4;
    // Make sure we don't spawn too close to the previous obstacle
    if(obstacles.length){
      const last = obstacles[obstacles.length-1];
      const desiredMinX = last.x + minHorizontalGap;
      if(atX < desiredMinX) atX = desiredMinX;
    }

    for(let i=0;i<attempts;i++){
      // choose lane but bias away from making tight alternating-lane pairs
      let lane = rand()<0.5?0:1;
      // if last obstacle exists and is too close and lane differs, prefer same lane to avoid blocking both
      const lastObs = obstacles[obstacles.length-1];
      if(lastObs && Math.abs(lastObs.x - atX) < minHorizontalGap && lastObs.lane !== lane){
        if(rand() < 0.8) lane = lastObs.lane; // high chance prefer same lane
      }

      // compute vertical limits for this lane
      const minH = Math.round(Math.max(8, player.r*0.9));
      const rawH = Math.round(H * (0.10 + rand()*0.28));
      let h = rawH;

      // safety vertical clearance to avoid blocking the other lane's center
      const minJumpClearance = Math.round(player.r * 1.2) + minJumpClearanceBase;

      if(lane === 1){
        // lower lane chimney: cap so it doesn't reach into upper lane center
        // compute vertical gap between lanes
        const laneGap = Math.max(0, laneY[1] - laneY[0]);
        const maxAllowedLowerH = Math.max(minH, laneGap - minJumpClearance - 4);
        h = Math.min(h, maxAllowedLowerH);
      } else {
        // upper lane: also keep reasonable maximum (don't create absurdly tall chimneys)
        const maxUpperH = Math.max(minH, Math.round(H * 0.36));
        h = Math.min(h, maxUpperH);
      }

      // final clamp to not be smaller than minH
      h = Math.max(minH, h);

      // If the computed max for lower lane ends up tiny (rare), fallback or retry
      if(h < minH){
        if(i < attempts-1) continue;
        h = minH;
      }

      // push obstacle with possibly adjusted atX
      obstacles.push({x:atX, lane:lane, h:h, w:Math.round(W*0.06), passed:false});
      return;
    }

    // fallback single simple obstacle
    const fallbackH = Math.max(8, Math.round(player.r*0.9));
    // if still here, push on lane 0
    let finalX = atX;
    if(obstacles.length){
      const last = obstacles[obstacles.length-1];
      const minGap = Math.max(Math.round(player.r*6), Math.round(W * 0.18));
      if(finalX < last.x + minGap) finalX = last.x + minGap;
    }
    obstacles.push({x:finalX, lane:0, h:fallbackH, w:Math.round(W*0.06), passed:false});
  }

  function pushLantern(x){ const lane = rand()<0.6?1:0; const offsetY = (rand()*0.3-0.15)*(lane===0?H*0.06:H*0.045); lanterns.push({x:x,lane:lane,offsetY:offsetY,taken:false}); }

  function circleRectCollision(cx,cy,r,rx,ry,rw,rh){
    const cx0 = Math.max(rx, Math.min(cx, rx+rw));
    const cy0 = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx-cx0, dy=cy-cy0;
    return (dx*dx + dy*dy)<(r*r+0.0001);
  }

  function setStrokeChalk(){ ctx.lineJoin='round'; ctx.lineCap='round'; ctx.lineWidth=Math.max(2,Math.min(W,H)*0.006); ctx.strokeStyle='rgba(242,243,244,0.96)'; }

  let lastTime=performance.now();
  function loop(now){
    const dt=Math.min(40, now-lastTime); lastTime=now; frame+=dt;
    if(!gameOver && playing){
      const move = speed*(dt/16);
      obstacles.forEach(o=>o.x -= move*laneSpeeds[o.lane]);
      lanterns.forEach(l=>l.x -= move*laneSpeeds[l.lane]);

      // recompute spawn gaps for this frame
      const minSpawnPx = Math.round(player.r * 6);
      const minHorizontalGap = Math.max(minSpawnPx, Math.round(W * 0.22));

      // spawn only when last obstacle is sufficiently left, and respecting minTimeGap
      if((obstacles.length===0 || (obstacles[obstacles.length-1].x < W - minHorizontalGap)) && (now - lastSpawnTime > minTimeGap)){
        pushObstacle(W + (minSpawnPx*0.6), {minHorizontalGap});
        lastSpawnTime = now;
      }

      if(obstacles[0]?.x < -200) obstacles.shift();
      if(lanterns[0]?.x < -200) lanterns.shift();

      obstacles.forEach(o=>{
        const rx=o.x-o.w/2, ry=(o.lane===0?laneY[0]-o.h:laneY[1]-o.h);
        if(circleRectCollision(player.x, player.y, player.r, rx, ry, o.w, o.h)){
          gameOver=true; playing=false; vibrate(80); playClick(); doGameOver();
        }
        if(!o.passed && o.x+o.w/2 < player.x){
          o.passed=true; score+=12; scoreEl.textContent='Score: '+Math.floor(score);
        }
      });

      lanterns.forEach(L=>{ if(!L.taken){
        const ly=laneY[L.lane]+L.offsetY;
        if(Math.hypot(player.x-L.x,player.y-ly) < player.r + Math.max(8,player.r*0.6)){
          L.taken=true; score+=30; spawnParticles(L.x,ly); vibrate(20); playClick(); scoreEl.textContent='Score: '+Math.floor(score);
        }
      }});

      speed += 0.0009*(dt/16);
      score += 0.01*(dt/16);
    }

    if(player.slideT>0){
      player.slideT+=dt;
      const pVal = Math.min(1, player.slideT/player.slideDur);
      const easing = 1-Math.pow(1-pVal,3);
      player.y = player.originY + (player.targetY-player.originY)*easing;
      if(player.slideT >= player.slideDur) { player.slideT=0; player.y=player.targetY; }
    }

    draw();
    requestAnimationFrame(loop);
  }

  function spawnParticles(x,y){
    for(let i=0;i<18;i++){
      particles.push({
        x: x + (rand()-0.5)*12,
        y: y + (rand()-0.5)*12,
        vx: (rand()-0.5)*2,
        vy: -1 - rand()*2,
        life: 800, age:0,
        c: (i%2===0? 'rgba(255,214,165,0.95)':'rgba(126,200,227,0.95)')
      });
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    const skyH = Math.round(H*0.18);
    ctx.save(); ctx.globalAlpha=0.28; ctx.fillStyle='rgba(35,52,63,0.06)'; ctx.fillRect(0,H-skyH-20,W,skyH+20); ctx.restore();

    for(let i=0;i<2;i++){
      const y=laneY[i], sp=laneSpeeds[i];
      ctx.save(); ctx.translate(-((frame*0.02*sp)%patternW),0);
      for(let px=-patternW;px<W+patternW;px+=patternW) drawRoof(px,y);
      ctx.restore();
    }

    lanterns.forEach(L=>{ if(!L.taken) drawLantern(L.x, laneY[L.lane]+L.offsetY); });
    obstacles.forEach(o=>drawChimney(o));

    particles.forEach(p=>{
      p.age+=16; p.x+=p.vx; p.y+=p.vy; p.vy+=0.06;
      ctx.beginPath(); ctx.fillStyle=p.c; ctx.globalAlpha=1-(p.age/p.life);
      ctx.ellipse(p.x,p.y,3,3,0,0,Math.PI*2); ctx.fill();
    });
    particles=particles.filter(p=>p.age<p.life);
    ctx.globalAlpha=1;

    drawPlayer();
    scoreEl.textContent='Score: '+Math.floor(score);
  }

  function drawRoof(x,y){
    ctx.beginPath(); setStrokeChalk(); ctx.strokeStyle='rgba(242,243,244,0.9)';
    ctx.moveTo(x,y); ctx.lineTo(x+20,y-6); ctx.lineTo(x+40,y+2); ctx.lineTo(x+80,y-4); ctx.lineTo(x+120,y+6); ctx.lineTo(x+patternW,y); ctx.stroke();
    ctx.beginPath(); ctx.strokeStyle='rgba(35,52,63,0.05)'; ctx.lineWidth=1; ctx.moveTo(x+6,y+6); ctx.lineTo(x+140,y+8); ctx.stroke();
  }

  function drawPlayer(){
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.06)'; ctx.ellipse(player.x+6,player.y+player.r*0.9,player.r*1.1,player.r*0.45,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.98)'; ctx.ellipse(player.x,player.y,player.r,player.r*0.95,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.95)'; ctx.lineWidth=Math.max(2,player.r*0.12); ctx.ellipse(player.x,player.y,player.r*0.86,player.r*0.82,0,0,Math.PI*2); ctx.stroke();
  }

  function drawChimney(o){
    const cx=o.x,l=o.lane,w=o.w,h=o.h,by=laneY[l]; const x=cx-w/2,y=by-h;
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.95)'; ctx.fillRect(x,y,w,h);
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.9)'; ctx.lineWidth=Math.max(2,W*0.006); ctx.strokeRect(x,y,w,h);
    ctx.beginPath(); ctx.fillStyle='rgba(35,52,63,0.98)'; ctx.fillRect(x-w*0.2,y-w*0.28,w*1.4,w*0.28);
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.9)'; ctx.strokeRect(x-w*0.2,y-w*0.28,w*1.4,w*0.28);
  }

  function drawLantern(x,y){
    ctx.beginPath(); ctx.fillStyle='rgba(255,214,165,0.08)'; ctx.ellipse(x,y,22,22,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle='rgba(255,214,165,0.98)'; ctx.ellipse(x,y,10,12,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.95)'; ctx.lineWidth=1.5; ctx.ellipse(x,y,10,12,0,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.strokeStyle='rgba(242,243,244,0.5)'; ctx.lineWidth=1; ctx.moveTo(x,y-12); ctx.lineTo(x,y-20); ctx.stroke();
  }

  function switchLane(){
    if(gameOver) return;
    if(!playing){ playing=true; tapHint.style.display='none'; }
    const nl=player.lane===0?1:0;
    player.originY=player.y; player.targetY=laneY[nl]; player.lane=nl; player.slideT=1;
    playClick(); vibrate(15);
  }

  function doGameOver(){
    modalTitle.textContent='You stumbled';
    modalText.textContent='Score: '+Math.floor(score)+' — Tap to retry';
    modal.classList.add('show');
    const prev=parseInt(localStorage.getItem('ss_highscore')||'0',10);
    if(Math.floor(score)>prev){ localStorage.setItem('ss_highscore',String(Math.floor(score))); modalTitle.textContent='New High Score!'; }
  }

  shareBtn.addEventListener('click', ()=>{
    try{ const link=document.createElement('a'); link.download=`shadow-step-${Date.now()}.png`; link.href=canvas.toDataURL('image/png'); link.click(); } catch(e){ window.open(canvas.toDataURL()); }
  });
  retryBtn.addEventListener('click', ()=>{ modal.classList.remove('show'); resetWorld(); });

  canvas.addEventListener('pointerdown', ()=>{
    if(gameOver) resetWorld();
    else switchLane();
  });
  window.addEventListener('keydown', e=>{
    if(e.code==='Space'){ e.preventDefault(); if(gameOver) resetWorld(); else switchLane(); }
  });

  // recompute sizes when the page first loads (ensure player.r/laneY in sync)
  dims();
  resetWorld();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
